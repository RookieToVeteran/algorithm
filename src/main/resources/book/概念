1 栈（stack）
    限定在尾部进行插入和删除操作的线性表。允许插入和删除操作的称为栈顶（top)，另一端称为栈底（bottom)。
因此，栈的操作是后进先出原则进行的。栈的基本运算包括：置空栈、入栈、出栈、取栈顶元素和判空。由于栈是受限的线性表，故可以由顺序表和链表来实现。

2 队列
    受限的线性表。它只允许在一端插入，称为队尾（rear)；另一端删除，称为对头（front），在队尾插入称为入队，对头删除称为出队。
基本运算包括：置空队、入队、出队、取队头和判队空。它也可以由顺序表或者链表来实现。

3 算法
    常见算法有查找和排序两种，其中查找是计算机数据处理经常用到的一种重要应用，当需要反复在海量数据中查找制定记录时，查找效率成为系统性能的关键。
查找算法分为静态查找和动态查找，其中静态查找包括：顺序查找、二分查找和分块查找；动态查找包括：二叉排序树和平衡二叉树。
此外还有理论上最快的查找技术——散列查找。
排序的目的是便于查找，比如电话号码查找、书的目录编排、字典查询等。排序和归并排序等常用的排序算法有：插入排序、冒泡排序、堆排序、选择

算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！



算法设计方法：
一、【分治法】
    分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

    分治法所能解决的问题一般具有以下几个特征：
    1) 该问题的规模缩小到一定的程度就可以容易地解决
    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。（前提）
    3) 利用该问题分解出的子问题的解可以合并为该问题的解；（最关键的一点）
    4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。
    上述的第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。
    分治法的基本步骤
    分治法在每一层递归上都有三个步骤：
    1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
    2)解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
    3)合并：将各个子问题的解合并为原问题的解。

    分治法的应用：1.递归与HANOI塔问题； 2.二分法求方程近似解    3. 用C++实现合并排序   4.求最大值和最小值的分治算法

二、【动态规划法】

    “最优化原理”如果用数学化一点的语言来描述的话，就是：假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，如若这个决策序列是最优的，对于任何一个整数k，1 < k < n，不论前面k个决策是怎样的，以后的最优决策只取决于由前面决策所确定的当前状态，即以后的决策Dk+1，Dk+2，…，Dn也是最优的。
    最优化原理是动态规划的基础，任何一个问题，如果失去了这个最优化原理的支持，就不可能用动态规划方法计算。能采用动态规划求解的问题都需要满足一定的条件：
    (1) 问题中的状态必须满足最优化原理；
    (2) 问题中的状态必须满足无后效性。
    所谓的无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结”。
    问题求解模式
    动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。
    初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

    动态规划决策过程示意图
    (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
    (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
    (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两段各状态之间的关系来确定决策。
    (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
    动态规划法的应用：1.动态规划求0/1背包问题      2.最长公共子串问题的实现 3. 用动态规划实现导弹拦截      4.最大化投资回报问题的实现


三、【贪心算法】
    所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。
    贪心算法的基本思路如下：
    1.建立数学模型来描述问题。
    2.把求解的问题分成若干个子问题。
    3.对每一子问题求解，得到子问题的局部最优解。
    4.把子问题的解局部最优解合成原来解问题的一个解。
    实现该算法的过程：
    从问题的某一初始解出发；
    while 能朝给定总目标前进一步 do
    求出可行解的一个解元素；
    由所有解元素组合成问题的一个可行解；
    值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。
    一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的

四、【回溯法】
    回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

    用回溯法解题的一般步骤：
    （1）针对所给问题，定义问题的解空间；
    （2）确定易于搜索的解空间结构；
    （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
    回溯法应用：1.回溯法之数的划分               2.回溯法求解 运动员最佳配对问题
    3.回溯法解决汽车加油次数最少问题 4. 用回溯法找出n个自然数中取r个数的全排列

五、【分支限界法】
    基本思想 ：分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。
    在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。 此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。
    常见的两种分支限界法：
    （1）队列式(FIFO)分支限界法
    按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。
    （2）优先队列式分支限界法
    按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。
    分支限界法与回溯法的不同:
    （1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。
    （2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。
    解空间树的动态搜索
    （1）回溯求解0/1背包问题，虽剪枝减少了搜索空间，但整个搜索按深度优先机械进行，是盲目搜索（不可预测本结点以下的结点进行的如何）。
    （2）回溯求解TSP也是盲目的（虽有目标函数，也只有找到一个可行解后才有意义）
    （3）分支限界法首先确定一个合理的限界函数，并根据限界函数确定目标函数的界[down, up]；然后按照广度优先策略遍历问题的解空间树，在某一分支上，依次搜索该结点的所有孩子结点，分别估算这些孩子结点的目标函数的可能取值（对最小化问题，估算结点的down，对最大化问题，估算结点的up）。如果某孩子结点的目标函数值超出目标函数的界，则将其丢弃（从此结点生成的解不会比目前已得的更好），否则入待处理表。
    分支限界法的设计思路
    设求解最大化问题，解向量为X=(x1,…,xn)，xi的取值范围为Si，|Si|=ri。在使用分支限界搜索问题的解空间树时，先根据限界函数估算目标函数的界[down, up]，然后从根结点出发，扩展根结点的r1个孩子结点，从而构成分量x1的r1种可能的取值方式。
    对这r1个孩子结点分别估算可能的目标函数bound(x1)，其含义：以该结点为根的子树所有可能的取值不大于bound(x1)，即：
    bound(x1)≥bound(x1,x2)≥…≥ bound(x1,…,xn)
    若某孩子结点的目标函数值超出目标函数的下界，则将该孩子结点丢弃；否则，将该孩子结点保存在待处理结点表PT中。
    再取PT表中目标函数极大值结点作为扩展的根结点，重复上述。
    直到一个叶子结点时的可行解X=(x1,…,xn)，及目标函数值bound(x1,…,xn)。
    分支限界法应用：1.分支限界法之装载问题       2. 分支限界法之布线问题
    3. 分支限界法之0 1背包问题 4. 分支限界法之旅行售货员问题